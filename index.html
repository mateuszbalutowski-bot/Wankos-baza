<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Wankos Baza</title>

  <style>
    :root{
      --bg:#0b0f17;
      --panel:#111827;
      --panel2:#0f172a;
      --text:#e5e7eb;
      --muted:#9ca3af;
      --accent:#60a5fa;
      --accent2:#34d399;
      --warn:#fbbf24;
      --danger:#fb7185;
      --ok:#22c55e;
      --border:rgba(255,255,255,0.07);
      --shadow: 0 12px 50px rgba(0,0,0,0.4);
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Noto Sans", Arial;
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family:var(--sans);
      background: radial-gradient(1200px 900px at 15% 10%, rgba(96,165,250,0.16), transparent 60%),
                  radial-gradient(1200px 900px at 90% 40%, rgba(52,211,153,0.12), transparent 55%),
                  var(--bg);
      color:var(--text);
      min-height:100vh;
    }

    header{
      padding:18px 18px;
      border-bottom:1px solid var(--border);
      background:rgba(17,24,39,0.6);
      backdrop-filter: blur(8px);
      position:sticky;
      top:0;
      z-index:10;
    }

    .wrap{ max-width:1200px; margin:0 auto; }

    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:18px;
      flex-wrap:wrap;
    }

    h1{
      margin:0;
      font-size:16px;
      letter-spacing:0.2px;
      font-weight:800;
    }

    .subtitle{
      margin-top:6px;
      color:var(--muted);
      font-size:12px;
      line-height:1.3;
    }

    .tabs{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }

    .tab{
      cursor:pointer;
      padding:9px 14px;
      border-radius:999px;
      border:1px solid var(--border);
      background: rgba(2,6,23,0.35);
      color: var(--muted);
      font-weight:800;
      font-size:12px;
      user-select:none;
      transition:.15s;
    }

    .tab:hover{ filter:brightness(1.08); transform: translateY(-1px); }

    .tab.active{
      color: #0b1220;
      border-color: rgba(96,165,250,0.35);
      background: linear-gradient(180deg, rgba(96,165,250,1), rgba(59,130,246,1));
    }

    main{ padding:20px 18px 80px; }

    .card{
      background: linear-gradient(180deg, rgba(17,24,39,0.95), rgba(15,23,42,0.95));
      border:1px solid var(--border);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:16px;
      overflow:hidden;
      margin-bottom:16px;
    }

    .card h2{
      margin:0;
      font-size:13px;
      font-weight:900;
      letter-spacing:0.2px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }

    .hint{
      margin-top:8px;
      font-size:12px;
      color:var(--muted);
      line-height:1.4;
    }

    textarea, input, select{
      width:100%;
      background: rgba(2,6,23,0.55);
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px 12px;
      color:var(--text);
      font-size:13px;
      outline:none;
      transition:0.15s;
      font-family:var(--sans);
    }

    textarea{
      min-height:160px;
      resize:vertical;
      font-family:var(--mono);
      line-height:1.35;
      font-size:12px;
      margin-top:12px;
    }

    textarea:focus, input:focus{
      border-color: rgba(96,165,250,0.5);
      box-shadow:0 0 0 4px rgba(96,165,250,0.12);
    }

    button{
      border:none;
      cursor:pointer;
      border-radius:12px;
      padding:10px 14px;
      font-weight:900;
      font-size:12px;
      transition:0.15s;
      display:inline-flex;
      align-items:center;
      gap:8px;
      color:#0b1220;
      background: linear-gradient(180deg, rgba(96,165,250,1), rgba(59,130,246,1));
    }

    button:hover{ transform: translateY(-1px); filter:brightness(1.05); }
    button:active{ transform: translateY(0px); filter:brightness(0.98); }

    .btn2{
      background: linear-gradient(180deg, rgba(52,211,153,1), rgba(16,185,129,1));
    }

    .btnDanger{
      background: linear-gradient(180deg, rgba(251,113,133,1), rgba(244,63,94,1));
    }

    .btnGhost{
      background: rgba(15,23,42,0.8);
      border:1px solid var(--border);
      color:var(--text);
    }

    .row{
      display:flex;
      gap:10px;
      margin-top:12px;
      flex-wrap:wrap;
      align-items:center;
    }

    .mono{ font-family:var(--mono); }

    .tag{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--border);
      font-size:11px;
      color:var(--muted);
      background: rgba(2,6,23,0.4);
      user-select:none;
      font-weight:900;
    }

    .tag.green{ color:rgba(34,197,94,0.95); border-color: rgba(34,197,94,0.25); }
    .tag.red{ color:rgba(251,113,133,0.95); border-color: rgba(251,113,133,0.25); }
    .tag.yellow{ color:rgba(251,191,36,0.95); border-color: rgba(251,191,36,0.25); }
    .tag.blue{ color:rgba(96,165,250,0.95); border-color: rgba(96,165,250,0.25); }

    .divider{
      height:1px;
      background: var(--border);
      margin: 14px 0;
    }

    .listBox{
      margin-top:12px;
      border:1px solid var(--border);
      border-radius:14px;
      background:rgba(2,6,23,0.35);
      overflow:hidden;
    }

    .item{
      padding:12px 12px;
      border-bottom:1px solid var(--border);
      cursor:pointer;
      transition:.12s;
    }
    .item:hover{ background: rgba(255,255,255,0.03); }
    .item:last-child{ border-bottom:none; }

    .inline{
      display:flex;
      justify-content:space-between;
      gap:12px;
      align-items:flex-start;
      flex-wrap:wrap;
    }

    .small{
      font-size:11px;
      color:var(--muted);
      line-height:1.4;
    }

    .table{
      width:100%;
      border-collapse: collapse;
      margin-top:12px;
      font-size:12px;
    }
    .table th, .table td{
      border-bottom:1px solid var(--border);
      padding:10px 8px;
      text-align:left;
      vertical-align:top;
    }
    .table th{
      font-size:11px;
      color:var(--muted);
      font-weight:900;
      text-transform:uppercase;
      letter-spacing:0.08em;
    }
    .right{ text-align:right; }

    .collapse{
      margin-top:10px;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid var(--border);
      background:rgba(2,6,23,0.35);
      display:none;
    }

    .legend{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-top:10px;
    }

    .toast{
      position: fixed;
      bottom: 20px;
      right: 20px;
      max-width: 360px;
      padding: 12px 14px;
      border-radius: 14px;
      border:1px solid var(--border);
      background: rgba(17,24,39,0.95);
      box-shadow: var(--shadow);
      color: var(--text);
      font-size: 12px;
      display:none;
      z-index:999;
    }
    .toast strong{
      display:block;
      margin-bottom:6px;
      font-size:12px;
    }

    .clickSource, .clickPlayer, .clickOwner{
      cursor:pointer;
      color: rgba(96,165,250,0.95);
      text-decoration: underline;
      font-weight:900;
    }
    .clickSource:hover, .clickPlayer:hover, .clickOwner:hover{
      filter: brightness(1.2);
    }

    .hidden{ display:none !important; }
  </style>
</head>

<body>
<header>
  <div class="wrap topbar">
    <div>
      <h1>Wankos Baza</h1>
      <div class="subtitle">
        Baza plemienna do notatek i analizy etykiet
        <br>
        <span id="userInfo" class="small"></span>
      </div>
    </div>

    <div class="tabs" id="tabsBar">
      <div class="tab active" data-tab="labels">Etykiety Atak√≥w</div>
      <div class="tab" data-tab="analysis">Analiza Etykiet</div>
      <div class="tab" data-tab="enemydb">Baza Wiosek Wroga</div>
      <div class="tab" data-tab="notes">Baza Notatek</div>
      <div class="tab" data-tab="settings">Ustawienia</div>
    </div>
  </div>
</header>

<main>
  <div class="wrap">

    <!-- TAB: LOGIN -->
    <div class="tabPanel" id="tab-login" style="display:none;">
      <div class="card">
        <h2>üîê Logowanie / Rejestracja <span class="tag blue">Konta</span></h2>

        <div class="hint">
          Rejestracja wymaga kodu plemienia.
          <br>Po rejestracji konto dzia≈Ça lokalnie (LocalStorage).
        </div>

        <div class="divider"></div>

        <h2>üìå Logowanie</h2>
        <div class="row">
          <input id="loginNick" placeholder="Nick w grze..." class="mono"/>
          <input id="loginPass" type="password" placeholder="Has≈Ço..."/>
        </div>
        <div class="row">
          <button id="btnLogin" class="btn2">Zaloguj</button>
        </div>

        <div class="divider"></div>

        <h2>‚ûï Rejestracja</h2>
        <div class="row">
          <input id="regNick" placeholder="Nick w grze..." class="mono"/>
          <input id="regPass" type="password" placeholder="Has≈Ço..."/>
          <input id="regCode" placeholder="Kod plemienia..." class="mono"/>
        </div>
        <div class="row">
          <button id="btnRegister">Zarejestruj konto</button>
        </div>
      </div>
    </div>

    <!-- TAB: LABELS -->
    <div class="tabPanel" id="tab-labels">
      <div class="card">
        <h2>
          üè∑Ô∏è Etykiety Atak√≥w
          <span class="tag blue">GLOBAL DB</span>
        </h2>

        <div class="hint">
          Wklej wszystkie etykiety z "Popro≈õ o pomoc". System zapisze je do globalnej bazy plemienia i automatycznie przypisze Twoje wioski do analizy atak√≥w.
        </div>

        <textarea id="labelsInput" placeholder="Wklej etykiety atak√≥w tutaj..."></textarea>

        <div class="row">
          <button id="btnParseLabels" class="btn2">üì• Wczytaj etykiety</button>
          <button id="btnClearLabels" class="btnGhost">üßπ Wyczy≈õƒá</button>
        </div>
<div id="labelsLoader" class="hidden" style="margin-top:12px;">
  <div class="small" id="labelsLoaderText">≈Åadowanie...</div>
  <div style="height:10px;border-radius:999px;border:1px solid var(--border);background:rgba(2,6,23,0.4);overflow:hidden;margin-top:8px;">
    <div id="labelsLoaderBar" style="height:100%;width:0%;background:linear-gradient(90deg, rgba(96,165,250,1), rgba(52,211,153,1));transition:width .2s;"></div>
  </div>
</div>

        <div class="divider"></div>

        <h2>üìå Podsumowanie</h2>
<div style="margin-top:12px;font-size:14px;font-weight:900;opacity:.9;">
  Etykiet w bazie plemienia: <b class="mono" id="tribeLabelsCount">...</b>
</div>
        <div id="labelsSummary" class="listBox">
          <div class="item small">Brak danych.</div>
        </div>
      </div>
    </div>

    <!-- TAB: ANALYSIS -->
    <div class="tabPanel" id="tab-analysis" style="display:none;">
      <div class="card">
        <h2>
          üìä Analiza Etykiet
          <span class="tag yellow">Threat Engine</span>
        </h2>

        <div class="hint">
          Widzisz tylko swoje wioski i etykiety, ale statystyki powtarzalno≈õci atak√≥w sƒÖ liczone globalnie.
        </div>

        <div class="row">
          <button id="btnRunThreat" class="btn2">‚ö° Przelicz ataki</button>
          <button id="btnClearThreat" class="btnGhost">üßπ Wyczy≈õƒá analizƒô</button>
        </div>

        <div id="threatBoard" class="listBox">
          <div class="item small">Brak analizy. Wklej etykiety w zak≈Çadce "Etykiety Atak√≥w".</div>
        </div>
      </div>
    </div>

    <!-- TAB: ENEMY DB -->
    <div class="tabPanel" id="tab-enemydb" style="display:none;">
      <div class="card">
        <h2>
          üè∞ Baza Wiosek Wroga
          <span class="tag green">Intel DB</span>
        </h2>

        <div class="hint">
          Lista wiosek z notatek. Kliknij aby zobaczyƒá informacje o wiosce.
        </div>

        <div class="legend">
          <span class="tag red">OFF - mo≈ºliwy FULL</span>
          <span class="tag yellow">OFF/MIX - podejrzana</span>
          <span class="tag green">DEFF / FEJK</span>
          <span class="tag blue">Niezidentyfikowany</span>
        </div>

        <div class="row">
          <input id="enemySearch" placeholder="Szukaj (np. 626|471)" class="mono"/>
          <button id="btnEnemySearch">Szukaj</button>
        </div>

        <div id="enemyList" class="listBox"></div>
<div class="divider"></div>

<h2>üî• Najbardziej aktywne wioski (≈∫r√≥d≈Ça atak√≥w)</h2>
<div class="hint">
  Ranking globalny na podstawie etykiet plemienia. Pokazuje te≈º ile atak√≥w idzie na Twoje wioski.
</div>

<div id="enemyTopSources" class="listBox">
  <div class="item small">Brak danych.</div>
</div>
        <div class="divider"></div>

        <h2>üéØ Profil wioski</h2>
        <div id="enemyProfile" class="listBox">
          <div class="item small">Kliknij wioskƒô aby zobaczyƒá szczeg√≥≈Çy.</div>
        </div>
      </div>
    </div>

    <!-- TAB: NOTES -->
    <div class="tabPanel" id="tab-notes" style="display:none;">
      <div class="card">
        <h2>
          üóíÔ∏è Tokeny z notatek
          <span id="adminTag" class="tag red">BRAK UPRAWNIE≈É</span>
        </h2>

        <div class="hint">
          Dodawanie token√≥w do bazy jest dostƒôpne tylko dla admina.
        </div>

        <textarea id="notesInput" placeholder="Wklej tokeny HN1/HN2..."></textarea>

        <div class="row">
          <button id="btnParseTokens">üîç Wczytaj tokeny</button>
          <button id="btnAddTokens" class="btn2">‚ûï Dodaj tokeny do bazy</button>
          <button id="btnClearNotes" class="btnGhost">üßπ Wyczy≈õƒá</button>
        </div>

        <div class="divider"></div>

        <h2>üìå Statystyki</h2>
        <div id="tokenStats" class="listBox">
          <div class="item small">Brak danych.</div>
        </div>
      </div>
    </div>

    <!-- TAB: SETTINGS -->
    <div class="tabPanel" id="tab-settings" style="display:none;">
      <div class="card">
        <h2>
          ‚öôÔ∏è Ustawienia
          <span class="tag blue">Panel</span>
        </h2>

        <div class="hint">
          U≈ºytkownik mo≈ºe usuwaƒá tylko swoje etykiety.
          Admin ma dostƒôp do pe≈Çnych narzƒôdzi.
        </div>

        <div class="divider"></div>

        <h2>üë§ Konto</h2>
        <div class="row">
          <button id="btnLogout" class="btnDanger">Wyloguj</button>
          <button id="btnDeleteMyLabels" class="btnDanger">Usu≈Ñ moje etykiety</button>
        </div>

        <div id="adminPanel" class="hidden">
          <div class="divider"></div>

          <h2>üëë Panel Admina</h2>
          <div class="hint">
            Mo≈ºesz nadawaƒá admina innym graczom oraz sprawdzaƒá kto dodawa≈Ç etykiety.
          </div>

          <div class="divider"></div>

          <h2>üß† ZarzƒÖdzanie adminami</h2>
          <div class="row">
            <input id="adminNickInput" placeholder="Nick gracza..." class="mono"/>
            <button id="btnGrantAdmin" class="btn2">Nadaj admina</button>
            <button id="btnRevokeAdmin" class="btnDanger">Usu≈Ñ admina</button>
          </div>

          <div class="divider"></div>

          <h2>üìå Statystyki plemienia</h2>
          <div id="adminStats" class="listBox">
            <div class="item small">Brak danych.</div>
          </div>

          <div class="divider"></div>

          <h2>üîç Profil u≈ºytkownika</h2>
          <div id="adminUserProfile" class="listBox">
            <div class="item small">Kliknij u≈ºytkownika powy≈ºej.</div>
          </div>

          <div class="divider"></div>

          <h2>üíæ Import / Export danych</h2>
          <div class="row">
            <button id="btnExport" class="btnGhost">Export JSON</button>
            <button id="btnImport" class="btnGhost">Import JSON</button>
          </div>

          <div class="divider"></div>

          <h2>üóëÔ∏è Reset bazy</h2>
          <div class="row">
            <button id="btnResetAll" class="btnDanger">Usu≈Ñ ca≈ÇƒÖ bazƒô</button>
            <button id="btnResetLabels" class="btnDanger">Usu≈Ñ globalne etykiety</button>
          </div>
        </div>
      </div>
    </div>

  </div>
</main>

<div class="toast" id="toast"></div>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script>
  const SUPABASE_URL = "https://cixrktawkfxaexhzhnho.supabase.co";
  const SUPABASE_ANON_KEY = "sb_publishable_kUYmC66z6c9g3qrj0hx2Zg_ZV__s0zA";
  const supa = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
</script>

<script>
/* ========= LZString minimal ========= */
var LZString=function(){function o(o,r){if(!t[o]){t[o]={};for(var n=0;n<o.length;n++)t[o][o.charAt(n)]=n}return t[o][r]}var r=String.fromCharCode,n="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",t={},i={compressToBase64:function(o){if(null==o)return"";var r=i._compress(o,6,function(o){return n.charAt(o)});switch(r.length%4){default:case 0:return r;case 1:return r+"===";case 2:return r+"==";case 3:return r+"="}},decompressFromBase64:function(r){return null==r?"":""==r?null:i._decompress(r.length,32,function(e){return o(n,r.charAt(e))})},_compress:function(o,r,n){if(null==o)return"";var e,t,i,s={},p={},u="",c="",a="",l=2,f=3,h=2,d=[],m=0,v=0;for(i=0;i<o.length;i+=1)if(u=o.charAt(i),Object.prototype.hasOwnProperty.call(s,u)||(s[u]=f++,p[u]=!0),c=a+u,Object.prototype.hasOwnProperty.call(s,c))a=c;else{if(Object.prototype.hasOwnProperty.call(p,a)){if(a.charCodeAt(0)<256){for(e=0;h>e;e++)m<<=1,v==r-1?(v=0,d.push(n(m)),m=0):v++;for(t=a.charCodeAt(0),e=0;8>e;e++)m=m<<1|1&t,v==r-1?(v=0,d.push(n(m)),m=0):v++,t>>=1}else{for(t=1,e=0;h>e;e++)m=m<<1|t,v==r-1?(v=0,d.push(n(m)),m=0):v++,t=0;for(t=a.charCodeAt(0),e=0;16>e;e++)m=m<<1|1&t,v==r-1?(v=0,d.push(n(m)),m=0):v++,t>>=1}l--,0==l&&(l=Math.pow(2,h),h++),delete p[a]}else for(t=s[a],e=0;h>e;e++)m=m<<1|1&t,v==r-1?(v=0,d.push(n(m)),m=0):v++,t>>=1;l--,0==l&&(l=Math.pow(2,h),h++),s[c]=f++,a=String(u)}if(""!==a){if(Object.prototype.hasOwnProperty.call(p,a)){if(a.charCodeAt(0)<256){for(e=0;h>e;e++)m<<=1,v==r-1?(v=0,d.push(n(m)),m=0):v++;for(t=a.charCodeAt(0),e=0;8>e;e++)m=m<<1|1&t,v==r-1?(v=0,d.push(n(m)),m=0):v++,t>>=1}else{for(t=1,e=0;h>e;e++)m=m<<1|t,v==r-1?(v=0,d.push(n(m)),m=0):v++,t=0;for(t=a.charCodeAt(0),e=0;16>e;e++)m=m<<1|1&t,v==r-1?(v=0,d.push(n(m)),m=0):v++,t>>=1}l--,0==l&&(l=Math.pow(2,h),h++),delete p[a]}else for(t=s[a],e=0;h>e;e++)m=m<<1|1&t,v==r-1?(v=0,d.push(n(m)),m=0):v++,t>>=1;l--,0==l&&(l=Math.pow(2,h),h++)}for(t=2,e=0;h>e;e++)m=m<<1|1&t,v==r-1?(v=0,d.push(n(m)),m=0):v++,t>>=1;for(;;){if(m<<=1,v==r-1){d.push(n(m));break}v++}return d.join("")},_decompress:function(o,n,e){var t,i,s,p,u,c,a,l,f=[],h=4,d=4,m=3,v="",w=[],A={val:e(0),position:n,index:1};for(i=0;3>i;i+=1)f[i]=i;for(p=0,c=Math.pow(2,2),a=1;a!=c;)u=A.val&A.position,A.position>>=1,0==A.position&&(A.position=n,A.val=e(A.index++)),p|=(u>0?1:0)*a,a<<=1;switch(t=p){case 0:for(p=0,c=Math.pow(2,8),a=1;a!=c;)u=A.val&A.position,A.position>>=1,0==A.position&&(A.position=n,A.val=e(A.index++)),p|=(u>0?1:0)*a,a<<=1;l=String.fromCharCode(p);break;case 1:for(p=0,c=Math.pow(2,16),a=1;a!=c;)u=A.val&A.position,A.position>>=1,0==A.position&&(A.position=n,A.val=e(A.index++)),p|=(u>0?1:0)*a,a<<=1;l=String.fromCharCode(p);break;case 2:return""}for(f[3]=l,s=l,w.push(l);;){if(A.index>o)return"";for(p=0,c=Math.pow(2,m),a=1;a!=c;)u=A.val&A.position,A.position>>=1,0==A.position&&(A.position=n,A.val=e(A.index++)),p|=(u>0?1:0)*a,a<<=1;switch(l=p){case 0:for(p=0,c=Math.pow(2,8),a=1;a!=c;)u=A.val&A.position,A.position>>=1,0==A.position&&(A.position=n,A.val=e(A.index++)),p|=(u>0?1:0)*a,a<<=1;f[d++]=String.fromCharCode(p),l=d-1,h--;break;case 1:for(p=0,c=Math.pow(2,16),a=1;a!=c;)u=A.val&A.position,A.position>>=1,0==A.position&&(A.position=n,A.val=e(A.index++)),p|=(u>0?1:0)*a,a<<=1;f[d++]=String.fromCharCode(p),l=d-1,h--;break;case 2:return w.join("")}if(0==h&&(h=Math.pow(2,m),m++),f[l])v=f[l];else{if(l!==d)return null;v=s+s.charAt(0)}w.push(v),f[d++]=s+v.charAt(0),h--,s=v,0==h&&(h=Math.pow(2,m),m++)}}
};return i}();

/* ===================== CONFIG ===================== */
const TRIBE_CODE = "Wankos2026";
const DEFAULT_ADMIN = "Jupiter";

const UNIT_ORDER = ["spear","sword","axe","spy","light","heavy","ram","catapult","knight","snob"];
const UNIT_LABELS = { spear:"Pik", sword:"Miecz", axe:"Top√≥r", spy:"Zwiad", light:"LK", heavy:"CK", ram:"Taran", catapult:"Kat", knight:"Rycerz", snob:"Szlach" };

const DB_KEY = "tribal_intel_enemy_db_v4";
const GLOBAL_LABELS_KEY = "tribal_intel_global_labels_v4";
const USERS_KEY = "tribal_intel_users_v4";
const SESSION_KEY = "tribal_intel_session_v4";
const ADMINS_KEY = "tribal_intel_admins_v4";
const MY_VILLAGES_KEY_PREFIX = "tribal_intel_my_villages_v4_";

const WORLD_SPEED = 2.0;

const CORE_BUILD_TIME = {
  axe: 205.04,
  light: 374.2,
  ram: 1335.3,
  catapult: 2002.9
};

const BUILD_TIME = {
  axe: CORE_BUILD_TIME.axe / WORLD_SPEED,
  light: CORE_BUILD_TIME.light / WORLD_SPEED,
  ram: CORE_BUILD_TIME.ram / WORLD_SPEED,
  catapult: CORE_BUILD_TIME.catapult / WORLD_SPEED
};

const FULL_OFF = {
  axe: 6000,
  light: 2800,
  ram: 400
};

const FULL_THRESHOLDS = {
  full: 0.80,
  medium: 0.40
};

/* ===================== UTIL ===================== */
function nowISO(){ return new Date().toISOString(); }

function toast(title, msg){
  const t = document.getElementById("toast");
  t.innerHTML = `<strong>${escapeHtml(title)}</strong>${escapeHtml(msg)}`;
  t.style.display = "block";
  setTimeout(()=>{ t.style.display="none"; }, 2600);
}

function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, m => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
  }[m]));
}

function groupBy(arr, keyFn){
  const m = {};
  for(const item of arr){
    const k = keyFn(item);
    if(!m[k]) m[k] = [];
    m[k].push(item);
  }
  return m;
}

function hoursBetween(fromTimestamp, toTimestamp){
  if(!fromTimestamp || !toTimestamp) return 0;
  return Math.max(0, (toTimestamp - fromTimestamp) / (1000*60*60));
}

function prettyHours(hours){
  hours = Math.floor(hours || 0);
  if(hours < 1) return "0h";
  if(hours < 24) return `${hours}h`;
  const d = Math.floor(hours / 24);
  const h = hours % 24;
  return `${d}d ${h}h`;
}

function normalizeNick(nick){
  return String(nick || "").trim();
}
function showLabelsLoader(text="≈Åadowanie...", pct=0){
  const box = document.getElementById("labelsLoader");
  const bar = document.getElementById("labelsLoaderBar");
  const t = document.getElementById("labelsLoaderText");

  box.classList.remove("hidden");
  t.textContent = text;
  bar.style.width = `${pct}%`;
}

function hideLabelsLoader(){
  const box = document.getElementById("labelsLoader");
  const bar = document.getElementById("labelsLoaderBar");
  box.classList.add("hidden");
  bar.style.width = "0%";
}

/* ===================== AUTH STORAGE (SUPABASE + FALLBACK LOCAL) ===================== */
async function loadUsers(){
  try{
    const { data, error } = await supa.from("profiles").select("nick, pass, is_admin, created_at");
    if(error) throw error;

    const users = {};
    for(const u of data){
      users[u.nick] = {
        nick: u.nick,
        pass: u.pass,
        is_admin: u.is_admin,
        createdAt: u.created_at || nowISO()
      };
    }
    return users;
  }catch(e){
    try{
      const raw = localStorage.getItem(USERS_KEY);
      if(!raw) return {};
      return JSON.parse(raw);
    }catch(err){ return {}; }
  }
}

async function saveUsers(users){
  localStorage.setItem(USERS_KEY, JSON.stringify(users));

  for(const nick in users){
    const u = users[nick];

    const { data, error } = await supa.from("profiles").upsert([{
      nick: u.nick,
      pass: u.pass,
      is_admin: u.is_admin || false
    }], { onConflict: "nick" });

    if(error){
      console.error("SUPABASE UPSERT ERROR:", error);
      toast("SUPABASE ERROR", error.message);
    }else{
      console.log("SUPABASE OK:", data);
    }
  }
}

function loadSession(){
  try{
    const raw = localStorage.getItem(SESSION_KEY);
    if(!raw) return null;
    return JSON.parse(raw);
  }catch(e){ return null; }
}
function saveSession(session){
  localStorage.setItem(SESSION_KEY, JSON.stringify(session));
}
function clearSession(){
  localStorage.removeItem(SESSION_KEY);
}

async function loadAdmins(){
  try{
    const { data, error } = await supa.from("profiles").select("nick").eq("is_admin", true);
    if(error) throw error;

    const list = data.map(x=>x.nick);
    if(!list.includes(DEFAULT_ADMIN)) list.push(DEFAULT_ADMIN);
    return list;
  }catch(e){
    try{
      const raw = localStorage.getItem(ADMINS_KEY);
      if(!raw) return [DEFAULT_ADMIN];
      const list = JSON.parse(raw);
      if(!Array.isArray(list)) return [DEFAULT_ADMIN];
      if(!list.includes(DEFAULT_ADMIN)) list.push(DEFAULT_ADMIN);
      return list;
    }catch(err){
      return [DEFAULT_ADMIN];
    }
  }
}

async function saveAdmins(list){
  localStorage.setItem(ADMINS_KEY, JSON.stringify(list));

  const { data } = await supa.from("profiles").select("nick");
  if(data){
    for(const u of data){
      const shouldBeAdmin = list.includes(u.nick);
      await supa.from("profiles").update({ is_admin: shouldBeAdmin }).eq("nick", u.nick);
    }
  }
}

function getCurrentUser(){
  const sess = loadSession();
  if(!sess || !sess.nick) return null;
  return { nick: sess.nick };
}

function isLoggedIn(){
  return !!getCurrentUser();
}

async function isAdmin(){
  const user = getCurrentUser();
  if(!user) return false;
  const admins = await loadAdmins();
  return admins.includes(user.nick);
}

function myVillagesKey(){
  const u = getCurrentUser();
  if(!u) return null;
  return MY_VILLAGES_KEY_PREFIX + u.nick;
}

async function loadMyVillages(){
  const user = getCurrentUser();
  if(!user) return [];

  try{
    const { data, error } = await supa
      .from("attack_labels")
      .select("defender")
      .eq("owner_nick", user.nick);

    if(error) throw error;

    const villages = [...new Set(data.map(x=>x.defender).filter(Boolean))];
    return villages;
  }catch(e){
    try{
      const key = myVillagesKey();
      if(!key) return [];
      const raw = localStorage.getItem(key);
      if(!raw) return [];
      const list = JSON.parse(raw);
      return Array.isArray(list) ? list : [];
    }catch(err){ return []; }
  }
}

async function saveMyVillages(list){
  const key = myVillagesKey();
  if(!key) return;
  localStorage.setItem(key, JSON.stringify(list));
}
async function updateTribeLabelsCount(){
  try{
    const { count, error } = await supa
      .from("attack_labels")
      .select("*", { count: "exact", head: true });

    if(error) throw error;

    document.getElementById("tribeLabelsCount").textContent = count ?? 0;

  }catch(e){
    console.error("updateTribeLabelsCount error:", e);
    document.getElementById("tribeLabelsCount").textContent = "B≈ÇƒÖd";
  }
}

/* ===================== STORAGE DB ===================== */
async function loadDB(){
  try{
    const { data, error } = await supa
      .from("enemy_tokens")
      .select("coords, token, type, troops, updated_at, added_by");

    if(error) throw error;

    const db = {};
    for(const row of data){
      db[row.coords] = {
        coords: row.coords,
        token: row.token,
        type: row.type,
        troops: row.troops || {},
        troopsAfter: row.troops || {},
        updatedAt: row.updated_at,
        addedBy: row.added_by
      };
    }

    return db;
  }catch(e){
    try{
      const raw = localStorage.getItem(DB_KEY);
      if(!raw) return {};
      return JSON.parse(raw);
    }catch(err){
      return {};
    }
  }
}

async function saveDB(db){
  localStorage.setItem(DB_KEY, JSON.stringify(db));

  for(const coords in db){
    const v = db[coords];

    await supa.from("enemy_tokens").upsert([{
      coords: coords,
      token: v.token,
      type: v.type,
      troops: v.troops,
      updated_at: nowISO(),
      added_by: getCurrentUser()?.nick || "UNKNOWN"
    }], { onConflict: "coords" });
  }
}

/* ===================== FIXED GLOBAL LABELS ===================== */
async function loadGlobalLabels(){
  try{
    let all = [];
    let from = 0;
    let step = 1000;

    while(true){
      const { data, error } = await supa
        .from("attack_labels")
        .select("owner_nick, defender, source, player, arrival, raw, created_at")
        .order("created_at", { ascending: true })
        .range(from, from + step - 1);

      if(error) throw error;

      if(!data || data.length === 0) break;

      all = all.concat(data);

      if(data.length < step) break;

      from += step;
    }

    return all.map(row => ({
      owner: row.owner_nick,
      defender: row.defender,
      source: row.source,
      player: row.player,
      arrival: row.arrival,
      raw: row.raw,
      createdAt: row.created_at
    }));

  }catch(e){
    console.error("loadGlobalLabels error:", e);

    try{
      const raw = localStorage.getItem(GLOBAL_LABELS_KEY);
      if(!raw) return [];
      return JSON.parse(raw);
    }catch(err){
      return [];
    }
  }
}

async function saveGlobalLabels(list){
  localStorage.setItem(GLOBAL_LABELS_KEY, JSON.stringify(list));

  try{
    // Zamiast pobieraƒá ca≈ÇƒÖ tabelƒô (co jest ciƒô≈ºkie),
    // robimy insert "na ≈õlepo" w chunkach.
    // Duplikaty i tak zostanƒÖ ewentualnie zaakceptowane (brak unique constraint),
    // ale kod dzia≈Ça du≈ºo szybciej.
    // Je≈õli chcesz 100% brak duplikat√≥w -> trzeba zrobiƒá unique index w Supabase.

    const toInsert = list.map(a => ({
      owner_nick: a.owner || "UNKNOWN",
      defender: a.defender,
      source: a.source,
      player: a.player,
      arrival: a.arrival,
      raw: a.raw
    }));

    if(toInsert.length === 0) return;

    const chunkSize = 250;
    for(let i=0; i<toInsert.length; i+=chunkSize){
      const chunk = toInsert.slice(i, i+chunkSize);

      const { error } = await supa
        .from("attack_labels")
        .insert(chunk);

      if(error){
        console.error("SUPABASE INSERT ERROR:", error);
        toast("SUPABASE ERROR", error.message);
        break;
      }
    }

  }catch(e){
    console.error("saveGlobalLabels error:", e);
    toast("B≈ÇƒÖd", "Nie uda≈Ço siƒô wys≈Çaƒá etykiet do Supabase.");
  }
}

/* ===================== TOKEN ===================== */
function decodeHN(token){
  token = token.trim();

  let version = null;
  let packed = null;

  if(token.startsWith("HN1:")){
    version = "HN1";
    packed = token.slice(4);
  }
  else if(token.startsWith("HN2:")){
    version = "HN2";
    packed = token.slice(4);
  }
  else{
    throw new Error("Token nie jest HN1 ani HN2");
  }

  const json = LZString.decompressFromBase64(packed);
  if(!json) throw new Error("Nie mo≈ºna zdekompresowaƒá tokenu");

  const obj = JSON.parse(json);
  obj._version = version;
  return obj;
}

function troopsArrayToObj(u){
  const o = {};
  for(let i=0;i<UNIT_ORDER.length;i++){
    o[UNIT_ORDER[i]] = Number(u[i] || 0);
  }
  return o;
}

function estimateOffPower(t){
  return (t.axe||0) + (t.light||0)*4 + (t.ram||0)*5 + (t.snob||0)*100;
}
function estimateDefPower(t){
  return (t.spear||0) + (t.sword||0)*1 + (t.heavy||0)*6;
}

function classifyVillage(t){
  const off = estimateOffPower(t);
  const def = estimateDefPower(t);
  if(off < 250 && def < 250) return "UNKNOWN";
  if(off > def*1.5 && off > 2500) return "OFF";
  if(def > off*1.5 && def > 2500) return "DEFF";
  return "MIX";
}

function villageColor(type, troops){
  const off = estimateOffPower(troops);
  if(type === "OFF" && off > 20000) return "red";
  if(type === "OFF" && off > 8000) return "yellow";
  if(type === "DEFF") return "green";
  if(type === "MIX") return "yellow";
  return "blue";
}

/* ===================== OFF REBUILD PREDICTION ===================== */
function predictRebuildMax(troopsAfter, hoursPassed){
  const predicted = JSON.parse(JSON.stringify(troopsAfter || {}));

  predicted.axe = (predicted.axe || 0) + Math.floor((hoursPassed * 3600) / BUILD_TIME.axe);
  predicted.light = (predicted.light || 0) + Math.floor((hoursPassed * 3600) / BUILD_TIME.light);
  predicted.ram = (predicted.ram || 0) + Math.floor((hoursPassed * 3600) / BUILD_TIME.ram);

  return predicted;
}

function calcFullOffPercent(troops){
  const axePct = (troops.axe || 0) / FULL_OFF.axe;
  const lightPct = (troops.light || 0) / FULL_OFF.light;
  const ramPct = (troops.ram || 0) / FULL_OFF.ram;
  return Math.max(0, Math.min(1, Math.min(axePct, lightPct, ramPct)));
}

function classifyOffThreatByPercent(percent){
  if(percent >= FULL_THRESHOLDS.full) return "FULL";
  if(percent >= FULL_THRESHOLDS.medium) return "MEDIUM";
  return "FAKE";
}

function threatColor(threat){
  if(threat === "FULL") return "red";
  if(threat === "MEDIUM") return "yellow";
  return "green";
}
function repeatColor(rep){
  rep = Number(rep || 0);

  if(rep <= 1) return "red";      // 1 atak
  if(rep <= 4) return "yellow";   // 2-4 ataki
  return "green";                 // 5+ atak√≥w
}
/* ===================== PARSERS ===================== */
function extractTokens(text){
  const re = /HN[12]:[A-Za-z0-9+\/=\-$]+/g;
  return text.match(re) || [];
}

function parseEnemyLabels(text){
  const lines = text.split("\n").map(x=>x.trim()).filter(Boolean);
  const attacks = [];

  let currentDefender = null;

  for(const line of lines){
    const villageMatch = line.match(/\[b\]Wioska:\[\/b\]\s*\[coord\](\d{1,3}\|\d{1,3})\[\/coord\]/);
    if(villageMatch){
      currentDefender = villageMatch[1];
      continue;
    }

    if(!line.includes("[command]attack[/command]")) continue;

    const sourceMatch = line.match(/\[coord\](\d{1,3}\|\d{1,3})\[\/coord\]/);
    const source = sourceMatch ? sourceMatch[1] : null;

    const playerMatch = line.match(/\[player\](.*?)\[\/player\]/);
    const player = playerMatch ? playerMatch[1] : "UNKNOWN";

    const arrivalMatch = line.match(/Czas przybycia:\s*(\d{2}\.\d{2}\.\d{2}\s+\d{2}:\d{2}:\d{2})/);
    const arrival = arrivalMatch ? arrivalMatch[1] : null;

    attacks.push({
      defender: currentDefender,
      source,
      player,
      arrival,
      raw: line,
      createdAt: nowISO()
    });
  }

  return attacks;
}

/* ===================== ANALYSIS ===================== */
function computeSourceRepeatability(allAttacks){
  const bySource = groupBy(allAttacks.filter(a=>a.source), a=>a.source);
  const map = {};
  for(const s in bySource){
    map[s] = bySource[s].length;
  }
  return map;
}

function detectFakeMachine(attacks){
  const bySource = groupBy(attacks.filter(a=>a.source && a.arrival), a=>a.source);
  const flagged = [];

  for(const src in bySource){
    const list = bySource[src].slice();

    const times = list.map(a=>{
      const parts = a.arrival.split(" ");
      const d = parts[0].split(".").map(Number);
      const t = parts[1].split(":").map(Number);
      const date = new Date(2000+d[2], d[1]-1, d[0], t[0], t[1], t[2]);
      return date.getTime();
    }).sort((a,b)=>a-b);

    let maxInWindow = 1;
    for(let i=0;i<times.length;i++){
      let j=i;
      while(j<times.length && times[j]-times[i] <= 60*1000) j++;
      maxInWindow = Math.max(maxInWindow, j-i);
    }

    if(maxInWindow >= 5){
      flagged.push({ source: src, burst: maxInWindow });
    }
  }

  return flagged;
}

function computeThreatForDefender(attacksForDefender, db, allAttacks){
  const sources = attacksForDefender.map(a=>a.source).filter(Boolean);
  const uniqueSources = [...new Set(sources)];

  let score = 0;
  score += Math.min(50, attacksForDefender.length * 6);
  score += Math.min(40, uniqueSources.length * 5);

  let offSources = 0;
  let deffSources = 0;
  let unknownSources = 0;
  let strongestOff = 0;

  for(const s of uniqueSources){
    const entry = db[s];
    if(!entry){
      unknownSources++;
      continue;
    }

    if(entry.type === "OFF") offSources++;
    else if(entry.type === "DEFF") deffSources++;
    else unknownSources++;

    const off = estimateOffPower(entry.troops);
    if(off > strongestOff) strongestOff = off;
  }

  score += offSources * 12;
  score -= deffSources * 8;
  score += unknownSources * 4;

  if(strongestOff > 8000) score += 10;
  if(strongestOff > 20000) score += 20;

  const repeatMap = computeSourceRepeatability(allAttacks);
  const maxRepeat = Math.max(0, ...uniqueSources.map(s => repeatMap[s] || 0));
  if(maxRepeat >= 6) score += 15;
  if(maxRepeat >= 12) score += 20;

  score = Math.max(0, Math.min(100, score));

  let verdict = "LOW";
  if(score >= 80) verdict = "CRITICAL";
  else if(score >= 55) verdict = "HIGH";
  else if(score >= 30) verdict = "MEDIUM";

  return { score, verdict, offSources, deffSources, unknownSources, strongestOff, maxRepeat };
}

/* ===================== RENDER ===================== */
async function renderTokenStats(foundTokensCount = null){
  const db = await loadDB();
  const villagesCount = Object.keys(db).length;

  let html = `<div class="item small">
    Zapisanych wiosek w bazie: <b class="mono">${villagesCount}</b>
  </div>`;

  if(foundTokensCount !== null){
    html = `<div class="item small">
      Wykryto token√≥w w notatkach: <b class="mono">${foundTokensCount}</b>
    </div>` + html;
  }

  document.getElementById("tokenStats").innerHTML = html;
}

async function renderEnemyDB(){
  const db = await loadDB();
  const keys = Object.keys(db);

  const box = document.getElementById("enemyList");
  if(keys.length === 0){
    box.innerHTML = `<div class="item small">Brak danych w bazie. Dodaj tokeny w zak≈Çadce "Baza Notatek".</div>`;
    return;
  }

  keys.sort((a,b)=> new Date(db[b].updatedAt).getTime() - new Date(db[a].updatedAt).getTime());

  let html = "";
  for(const coords of keys.slice(0,200)){
    const entry = db[coords];
    const baseTroops = entry.troopsAfter || entry.troops || {};
    const hours = entry.reportTime ? hoursBetween(entry.reportTime, Date.now()) : 0;
    const predicted = predictRebuildMax(baseTroops, hours);

    const color = villageColor(entry.type, predicted);

    let label = "";

    if(entry.type === "OFF"){
      const pct = calcFullOffPercent(predicted);
      const threat = classifyOffThreatByPercent(pct);

      if(entry.offKilledAt){
        const offHours = hoursBetween(entry.offKilledAt, Date.now());
        label = `OFF pad≈Ç ${prettyHours(offHours)} temu ‚Ä¢ ${Math.round(pct*100)}% FULL ‚Ä¢ ${threat}`;
      }else{
        label = `OFF ‚Ä¢ ${Math.round(pct*100)}% FULL ‚Ä¢ ${threat}`;
      }
    }
    else if(entry.type === "DEFF"){
      label = "DEFF - mo≈ºliwy FEJK";
    }
    else if(entry.type === "MIX"){
      label = "MIX - podejrzana";
    }
    else{
      label = "UNKNOWN";
    }

    html += `
      <div class="item" data-coords="${coords}">
        <div class="inline">
          <div>
            <div class="mono"><b>${coords}</b></div>
            <div class="small">${escapeHtml(label)}</div>
          </div>
          <span class="tag ${color}">${entry.type}</span>
        </div>
      </div>
    `;
  }

  box.innerHTML = html;

  for(const el of box.querySelectorAll("[data-coords]")){
    el.addEventListener("click", ()=>{
      renderEnemyProfile(el.getAttribute("data-coords"));
    });
  }
}

async function renderEnemyProfile(coords){
  const db = await loadDB();
  const entry = db[coords];
  const box = document.getElementById("enemyProfile");

  if(!entry){
    box.innerHTML = `<div class="item small">Brak danych o wiosce ${coords}.</div>`;
    return;
  }

  const baseTroops = entry.troopsAfter || entry.troops || {};
  const hours = entry.reportTime ? hoursBetween(entry.reportTime, Date.now()) : 0;
  const predicted = predictRebuildMax(baseTroops, hours);

  let table = `<table class="table"><thead><tr><th>Jednostka</th><th class="right">Ilo≈õƒá (prognoza)</th></tr></thead><tbody>`;
  for(const u of UNIT_ORDER){
    table += `<tr><td>${UNIT_LABELS[u]}</td><td class="right mono">${predicted[u]||0}</td></tr>`;
  }
  table += `</tbody></table>`;

  const off = estimateOffPower(predicted);
  const def = estimateDefPower(predicted);

  let offKilledInfo = "";
  if(entry.offKilledAt){
    const offHours = hoursBetween(entry.offKilledAt, Date.now());
    offKilledInfo = `<div class="small">üî• OFF pad≈Ç: <b class="mono">${prettyHours(offHours)} temu</b></div>`;
  }

  let reportInfo = "";
  if(entry.reportTime){
    reportInfo = `<div class="small">Raport: <b class="mono">${prettyHours(hours)} temu</b></div>`;
  }

  let percentInfo = "";
  if(entry.type === "OFF"){
    const pct = calcFullOffPercent(predicted);
    const threat = classifyOffThreatByPercent(pct);
    percentInfo = `<div class="small">OFF prognoza: <b class="mono">${Math.round(pct*100)}%</b> FULL ‚Ä¢ <span class="tag ${threatColor(threat)}">${threat}</span></div>`;
  }

  const admin = await isAdmin();

  box.innerHTML = `
    <div class="item">
      <div class="inline">
        <div class="mono" style="font-weight:900;font-size:14px;">${coords}</div>
        <span class="tag ${villageColor(entry.type, predicted)}">${entry.type}</span>
      </div>

      <div class="small">Aktualizacja: <span class="mono">${new Date(entry.updatedAt).toLocaleString()}</span></div>
      ${reportInfo}
      ${offKilledInfo}

      ${admin ? `
      <div class="row" style="margin-top:12px;">
        <button class="btnDanger" id="btnDeleteVillage">üóëÔ∏è Usu≈Ñ wioskƒô z bazy</button>
      </div>` : ``}

      <div class="divider"></div>

      <div class="small">OFF power: <span class="mono">${Math.round(off)}</span> ‚Ä¢ DEF power: <span class="mono">${Math.round(def)}</span></div>
      ${percentInfo}

      ${table}
    </div>
  `;

  if(admin){
    document.getElementById("btnDeleteVillage").addEventListener("click", async ()=>{
      if(!confirm("Na pewno usunƒÖƒá tƒô wioskƒô z bazy?")) return;

      const db = await loadDB();
      delete db[coords];
      await saveDB(db);

      toast("Baza", `Usuniƒôto wioskƒô ${coords}.`);
      await renderEnemyDB();

      box.innerHTML = `<div class="item small">Wioska ${coords} zosta≈Ça usuniƒôta z bazy.</div>`;
    });
  }
}
let TOP_SOURCES_LIMIT = 15;

async function renderTopEnemySources(){
  const box = document.getElementById("enemyTopSources");

  try{
    const all = await loadGlobalLabels();
    const myVillages = await loadMyVillages();

    const onlySources = all.filter(a => a.source && a.source.includes("|"));

    if(onlySources.length === 0){
      box.innerHTML = `<div class="item small">Brak danych w bazie etykiet.</div>`;
      return;
    }

    const bySource = groupBy(onlySources, a=>a.source);

    const list = Object.keys(bySource).map(src => {
      const attacks = bySource[src];

      // najczƒôstszy gracz z tej wioski
      const byPlayer = groupBy(attacks.filter(a=>a.player), a=>a.player);
      let topPlayer = "UNKNOWN";
      let topPlayerCount = 0;

      for(const p in byPlayer){
        if(byPlayer[p].length > topPlayerCount){
          topPlayerCount = byPlayer[p].length;
          topPlayer = p;
        }
      }

      const myAttacks = attacks.filter(a => myVillages.includes(a.defender));
      const onMe = myAttacks.length;

      // grupowanie po defender (Twoje wioski)
      const byDef = groupBy(myAttacks.filter(a=>a.defender), a=>a.defender);

      const defendersList = Object.keys(byDef).map(def => ({
        defender: def,
        count: byDef[def].length,
        attacks: byDef[def].sort((a,b)=>{
          // sortuj po arrival je≈õli jest
          if(!a.arrival) return 1;
          if(!b.arrival) return -1;
          return String(a.arrival).localeCompare(String(b.arrival));
        })
      })).sort((a,b)=> b.count - a.count);

      return {
        source: src,
        count: attacks.length,
        onMe: onMe,
        defenders: defendersList,
        topPlayer: topPlayer,
        topPlayerCount: topPlayerCount
      };
    });

    list.sort((a,b)=> b.count - a.count);

    const visible = list.slice(0, TOP_SOURCES_LIMIT);

    let html = "";
    for(const item of visible){
      const tagColor = item.onMe > 0 ? "red" : "blue";

      const onMeText = item.onMe > 0
        ? `<div class="small" style="margin-top:4px;opacity:.9;">‚ö†Ô∏è Na Ciebie: <b class="mono">${item.onMe}</b></div>`
        : `<div class="small" style="margin-top:4px;opacity:.6;">Brak atak√≥w na Ciebie</div>`;

      const playerHtml = item.topPlayer && item.topPlayer !== "UNKNOWN"
        ? `<div class="small" style="margin-top:4px;opacity:.85;">
            üë§ Najczƒô≈õciej: <b class="clickPlayer" data-player="${escapeHtml(item.topPlayer)}">${escapeHtml(item.topPlayer)}</b>
          </div>`
        : `<div class="small" style="margin-top:4px;opacity:.6;">üë§ Brak danych gracza</div>`;

      html += `
        <div class="item" data-src="${item.source}">
          <div class="inline">
            <div>
              <div class="mono"><b>${item.source}</b></div>
              ${playerHtml}
              ${onMeText}
            </div>
            <span class="tag ${tagColor}">${item.count} atak√≥w</span>
          </div>

          <div class="collapse" style="display:none;"></div>
        </div>
      `;
    }

    // przycisk "za≈Çaduj wiƒôcej"
    if(TOP_SOURCES_LIMIT < list.length){
      html += `
        <div class="item" style="text-align:center;">
          <button id="btnLoadMoreSources" class="btn2">‚ûï Za≈Çaduj wiƒôcej</button>
          <div class="small" style="margin-top:8px;opacity:.75;">
            Pokazano: <b class="mono">${TOP_SOURCES_LIMIT}</b> / <b class="mono">${list.length}</b>
          </div>
        </div>
      `;
    }else{
      html += `
        <div class="item small" style="text-align:center;opacity:.7;">
          Pokazano wszystkie ≈∫r√≥d≈Ça: <b class="mono">${list.length}</b>
        </div>
      `;
    }

    box.innerHTML = html;

    // klik w player (jak w analizie)
   box.querySelectorAll(".clickPlayer").forEach(el=>{
  el.addEventListener("click", (e)=>{
    e.stopPropagation();

    const player = el.getAttribute("data-player");
    const parentItem = el.closest(".item");
    if(!parentItem) return;

    let collapse = parentItem.querySelector(".playerCollapse");

    // je≈õli ju≈º istnieje -> toggle
    if(collapse){
      collapse.style.display = (collapse.style.display === "block") ? "none" : "block";
      return;
    }

    collapse = document.createElement("div");
    collapse.className = "collapse playerCollapse";
    collapse.style.display = "block";
    parentItem.appendChild(collapse);

    const playerAttacks = all.filter(a => (a.player || "UNKNOWN") === player);
    const byVillage = groupBy(playerAttacks.filter(a=>a.source), a=>a.source);

    let html = `
      <div style="padding:10px;border-bottom:1px solid var(--border);">
        <div class="mono" style="font-weight:900;">Gracz: ${escapeHtml(player)}</div>
        <div class="small">≈ÅƒÖcznie atak√≥w (globalnie): <b class="mono">${playerAttacks.length}</b></div>
        <div class="small" style="margin-top:4px;opacity:.8;">Kliknij wioskƒô aby przej≈õƒá do profilu.</div>
      </div>
    `;

    const villages = Object.keys(byVillage).sort((a,b)=> byVillage[b].length - byVillage[a].length);

    for(const v of villages.slice(0, 50)){
      html += `
        <div class="item" style="border-bottom:1px solid var(--border);" data-src="${v}">
          <div class="inline">
            <div class="mono"><b>${v}</b></div>
            <span class="tag blue">${byVillage[v].length} atak√≥w</span>
          </div>
        </div>
      `;
    }

    collapse.innerHTML = html;

    collapse.querySelectorAll("[data-src]").forEach(srcEl=>{
      srcEl.addEventListener("click", async (ev)=>{
        ev.stopPropagation();
        const coords = srcEl.getAttribute("data-src");
        await renderEnemyProfile(coords);
      });
    });
  });
});

    // klik w ≈∫r√≥d≈Ço (wioskƒô)
    box.querySelectorAll("[data-src]").forEach(el=>{
      el.addEventListener("click", async ()=>{
        const coords = el.getAttribute("data-src");

        await renderEnemyProfile(coords);

        const collapse = el.querySelector(".collapse");
        if(!collapse) return;

        if(collapse.style.display === "block"){
          collapse.style.display = "none";
          collapse.innerHTML = "";
          return;
        }

        const found = list.find(x => x.source === coords);
        if(!found) return;

        if(found.onMe === 0){
          collapse.innerHTML = `<div class="small" style="padding:10px;opacity:.75;">Brak atak√≥w na Twoje wioski.</div>`;
          collapse.style.display = "block";
          return;
        }

        let inside = `
          <div style="padding:10px;border-bottom:1px solid var(--border);">
            <div class="small" style="opacity:.9;">
              üéØ Ataki z <b class="mono">${coords}</b> na Twoje wioski:
            </div>
          </div>
        `;

        for(const d of found.defenders){
          inside += `
            <div style="padding:10px;border-bottom:1px solid var(--border);">
              <div class="inline">
                <div class="mono"><b>${d.defender}</b></div>
                <span class="tag yellow">${d.count} atak√≥w</span>
              </div>
        `;

          // szczeg√≥≈Çy atak√≥w
          for(const a of d.attacks.slice(0, 8)){
            inside += `
              <div class="small" style="margin-top:6px;opacity:.85;">
                ‚è± ${escapeHtml(a.arrival || "??")} ‚Ä¢ üë§ <b>${escapeHtml(a.player || "UNKNOWN")}</b>
              </div>
            `;
          }

          if(d.attacks.length > 8){
            inside += `
              <div class="small" style="margin-top:6px;opacity:.65;">
                +${d.attacks.length - 8} kolejnych atak√≥w...
              </div>
            `;
          }

          inside += `</div>`;
        }

        collapse.innerHTML = inside;
        collapse.style.display = "block";
      });
    });

    // load more
    const btn = document.getElementById("btnLoadMoreSources");
    if(btn){
      btn.addEventListener("click", ()=>{
        TOP_SOURCES_LIMIT += 30;
        renderTopEnemySources();
      });
    }

  }catch(e){
    console.error(e);
    box.innerHTML = `<div class="item small">B≈ÇƒÖd ≈Çadowania rankingu.</div>`;
  }
}
async function renderThreatBoard(){
  const db = await loadDB();
  const allAttacks = await loadGlobalLabels();
  const myVillages = await loadMyVillages();

  const board = document.getElementById("threatBoard");
  if(allAttacks.length === 0){
    board.innerHTML = `<div class="item small">Brak etykiet. Wklej dane w zak≈Çadce "Etykiety Atak√≥w".</div>`;
    return;
  }

  if(myVillages.length === 0){
    board.innerHTML = `<div class="item small">Nie masz przypisanych wiosek defender. Wklej swoje etykiety w zak≈Çadce "Etykiety Atak√≥w".</div>`;
    return;
  }

  const myAttacks = allAttacks.filter(a => myVillages.includes(a.defender));

  if(myAttacks.length === 0){
    board.innerHTML = `<div class="item small">Brak atak√≥w na Twoje wioski.</div>`;
    return;
  }

  const byDef = groupBy(myAttacks.filter(a=>a.defender), a=>a.defender);
  const defenders = Object.keys(byDef);

  const results = defenders.map(def=>{
    const threat = computeThreatForDefender(byDef[def], db, allAttacks);
    return { defender:def, attacks:byDef[def], ...threat };
  });

  results.sort((a,b)=> b.score - a.score);

  const repeatMap = computeSourceRepeatability(allAttacks);
  const fakeMachines = detectFakeMachine(allAttacks);
  const fakeMap = {};
  for(const f of fakeMachines){
    fakeMap[f.source] = f.burst;
  }

  let html = "";
  for(const r of results){
    const color = r.verdict === "CRITICAL"
      ? "red"
      : r.verdict === "HIGH"
      ? "yellow"
      : r.verdict === "MEDIUM"
      ? "yellow"
      : "green";

    html += `
      <div class="item" data-def="${r.defender}">
        <div class="inline">
          <div>
            <div class="mono" style="font-weight:900;">${r.defender}</div>
            <div class="small">
              Atak√≥w: <b class="mono">${r.attacks.length}</b> ‚Ä¢ ≈πr√≥de≈Ç: <b class="mono">${new Set(r.attacks.map(x=>x.source)).size}</b>
              ‚Ä¢ Max powtarzalno≈õƒá ≈∫r√≥d≈Ça: <b class="mono">${r.maxRepeat}</b>
            </div>
          </div>
          <span class="tag ${color}">${r.verdict} ${Math.round(r.score)}%</span>
        </div>

        <div class="collapse" id="collapse-${r.defender.replace('|','_')}"></div>
      </div>
    `;
  }

  board.innerHTML = html;

  for(const item of board.querySelectorAll("[data-def]")){
    item.addEventListener("click", ()=>{
      const def = item.getAttribute("data-def");
      const collapse = item.querySelector(".collapse");

      if(collapse.style.display === "block"){
        collapse.style.display = "none";
        collapse.innerHTML = "";
        return;
      }

      const list = byDef[def];

      const attacksHtml = list.map(a=>{
        const src = a.source || "???";
        const rep = repeatMap[src] || 1;
const repColor = repeatColor(rep);

        let srcType = "UNKNOWN";
        let srcTagColor = "blue";

        if(db[src]){
          srcType = db[src].type;
          srcTagColor = villageColor(db[src].type, db[src].troops || {});
        }

        const fakeBurst = fakeMap[src] || 0;
        const burstText = fakeBurst >= 5 ? `‚ö†Ô∏è FEJKOMAT (${fakeBurst}/1min)` : "";

        return `
          <div style="padding:10px;border-bottom:1px solid var(--border);">
            <div class="inline">
              <div>
                <div class="mono">
                  <b class="clickSource" data-src="${src}">${src}</b> ‚Üí <b>${def}</b>
                </div>

                <div class="small">
                  Gracz:
                  <b class="clickPlayer" data-player="${escapeHtml(a.player||"UNKNOWN")}">${escapeHtml(a.player||"UNKNOWN")}</b>
                  ‚Ä¢ Przybycie: <span class="mono">${a.arrival||"??"}</span>
                </div>

                <div class="small">
  Powtarzalno≈õƒá atak√≥w z tej wioski:
  <span class="tag ${repColor}">${rep}</span>
  ‚Ä¢ ${burstText}
</div>

                <div class="small">
                  Dodane przez: <b class="clickOwner" data-owner="${escapeHtml(a.owner||"UNKNOWN")}">${escapeHtml(a.owner||"UNKNOWN")}</b>
                </div>
              </div>

              <span class="tag ${srcTagColor}">${srcType}</span>
            </div>

            <div class="small mono" style="opacity:.65;margin-top:6px;">${escapeHtml(a.raw)}</div>
          </div>
        `;
      }).join("");

      collapse.innerHTML = attacksHtml || `<div class="small">Brak atak√≥w.</div>`;
      collapse.style.display = "block";

      collapse.querySelectorAll(".clickSource").forEach(el=>{
        el.addEventListener("click", (e)=>{
          e.stopPropagation();
          const coords = el.getAttribute("data-src");
          switchTab("enemydb");
          renderEnemyProfile(coords);
        });
      });

      collapse.querySelectorAll(".clickPlayer").forEach(el=>{
        el.addEventListener("click", (e)=>{
          e.stopPropagation();

          const player = el.getAttribute("data-player");

          const playerAttacks = allAttacks.filter(a => (a.player || "UNKNOWN") === player);
          const byVillage = groupBy(playerAttacks.filter(a=>a.source), a=>a.source);

          let html = `
            <div style="padding:10px;border-bottom:1px solid var(--border);">
              <div class="mono" style="font-weight:900;">Gracz: ${escapeHtml(player)}</div>
              <div class="small">≈ÅƒÖcznie atak√≥w (globalnie): <b class="mono">${playerAttacks.length}</b></div>
              <div class="small" style="margin-top:4px;opacity:.8;">Kliknij wioskƒô aby przej≈õƒá do profilu.</div>
            </div>
          `;

          const villages = Object.keys(byVillage).sort((a,b)=> byVillage[b].length - byVillage[a].length);

          for(const v of villages){
            html += `
              <div class="item" style="border-bottom:1px solid var(--border);" data-src="${v}">
                <div class="inline">
                  <div class="mono"><b>${v}</b></div>
                  <span class="tag blue">${byVillage[v].length} atak√≥w</span>
                </div>
              </div>
            `;
          }

          collapse.innerHTML = html;

          collapse.querySelectorAll("[data-src]").forEach(srcEl=>{
            srcEl.addEventListener("click", (ev)=>{
              ev.stopPropagation();
              const coords = srcEl.getAttribute("data-src");

              switchTab("enemydb");
              renderEnemyProfile(coords);
            });
          });
        });
      });

      collapse.querySelectorAll(".clickOwner").forEach(el=>{
        el.addEventListener("click", async (e)=>{
          e.stopPropagation();
          const owner = el.getAttribute("data-owner");

          if(await isAdmin()){
            switchTab("settings");
            renderAdminUserProfile(owner);
          }else{
            toast("Info", `Etykiety doda≈Ç: ${owner}`);
          }
        });
      });
    });
  }
}

/* ===================== ADMIN RENDER ===================== */
async function renderAdminStats(){
  if(!(await isAdmin())) return;

  const all = await loadGlobalLabels();

  if(all.length === 0){
    document.getElementById("adminStats").innerHTML =
      `<div class="item small">Brak danych w bazie etykiet.</div>`;
    return;
  }

  const byOwner = groupBy(all.filter(a=>a.owner), a=>a.owner);

  const owners = Object.keys(byOwner).sort((a,b)=> byOwner[b].length - byOwner[a].length);

  let html = "";
  for(const o of owners){
    html += `
      <div class="item" data-owner="${escapeHtml(o)}">
        <div class="inline">
          <div>
            <div class="mono"><b class="clickOwner">${escapeHtml(o)}</b></div>
            <div class="small">Dodane ataki: <b class="mono">${byOwner[o].length}</b></div>
          </div>
          <span class="tag blue">USER</span>
        </div>
      </div>
    `;
  }

  const box = document.getElementById("adminStats");
  box.innerHTML = html;

  box.querySelectorAll("[data-owner]").forEach(el=>{
    el.addEventListener("click", ()=>{
      const owner = el.getAttribute("data-owner");
      renderAdminUserProfile(owner);
    });
  });
}

async function renderAdminUserProfile(ownerNick){
  if(!(await isAdmin())) return;

  const all = await loadGlobalLabels();
  const myAttacks = all.filter(a => (a.owner || "UNKNOWN") === ownerNick);

  if(myAttacks.length === 0){
    document.getElementById("adminUserProfile").innerHTML =
      `<div class="item small">Brak danych o u≈ºytkowniku ${escapeHtml(ownerNick)}.</div>`;
    return;
  }

  const byDef = groupBy(myAttacks.filter(a=>a.defender), a=>a.defender);
  const bySrc = groupBy(myAttacks.filter(a=>a.source), a=>a.source);

  const defs = Object.keys(byDef);
  const srcs = Object.keys(bySrc).sort((a,b)=> bySrc[b].length - bySrc[a].length);

  let html = `
    <div class="item">
      <div class="mono" style="font-weight:900;font-size:14px;">üë§ ${escapeHtml(ownerNick)}</div>
      <div class="small">Dodanych atak√≥w: <b class="mono">${myAttacks.length}</b></div>
      <div class="small">Defender√≥w: <b class="mono">${defs.length}</b></div>
      <div class="divider"></div>

      <button class="btnDanger" id="btnDeleteUserLabels">üóëÔ∏è Usu≈Ñ etykiety tego u≈ºytkownika</button>
    </div>
  `;

  html += `
    <div class="item small" style="opacity:.9;">
      <b>Defendery u≈ºytkownika:</b><br>
      ${defs.map(d=>`<span class="mono">${escapeHtml(d)}</span>`).join(", ")}
    </div>
  `;

  html += `
    <div class="item small" style="opacity:.9;">
      <b>≈πr√≥d≈Ça atak√≥w (source):</b>
    </div>
  `;

  for(const s of srcs.slice(0,80)){
    html += `
      <div class="item" data-src="${escapeHtml(s)}">
        <div class="inline">
          <div class="mono"><b>${escapeHtml(s)}</b></div>
          <span class="tag yellow">${bySrc[s].length} atak√≥w</span>
        </div>
      </div>
    `;
  }

  document.getElementById("adminUserProfile").innerHTML = html;

  document.getElementById("btnDeleteUserLabels").addEventListener("click", async ()=>{
    if(!confirm(`UsunƒÖƒá wszystkie etykiety dodane przez ${ownerNick}?`)) return;

    await supa.from("attack_labels").delete().eq("owner_nick", ownerNick);

    toast("Admin", `Usuniƒôto etykiety u≈ºytkownika ${ownerNick}.`);
    await renderAdminStats();
    document.getElementById("adminUserProfile").innerHTML = `<div class="item small">Usuniƒôto dane u≈ºytkownika.</div>`;
    await updateTribeLabelsCount();
  });

  document.querySelectorAll("#adminUserProfile [data-src]").forEach(el=>{
    el.addEventListener("click", ()=>{
      const coords = el.getAttribute("data-src");
      switchTab("enemydb");
      renderEnemyProfile(coords);
    });
  });
}

/* ===================== UI AUTH ===================== */
async function updateUserUI(){
  const user = getCurrentUser();
  const info = document.getElementById("userInfo");

  if(!user){
    info.innerHTML = `<span class="tag red">NIEZALOGOWANY</span>`;
    return;
  }

  const admin = await isAdmin();
  const role = admin ? `<span class="tag green">ADMIN</span>` : `<span class="tag blue">USER</span>`;

  info.innerHTML = `Zalogowany: <b class="mono">${escapeHtml(user.nick)}</b> ${role}`;

  document.getElementById("adminTag").className = admin ? "tag green" : "tag red";
  document.getElementById("adminTag").textContent = admin ? "ADMIN" : "BRAK UPRAWNIE≈É";

  document.getElementById("adminPanel").classList.toggle("hidden", !admin);
}

/* ===================== TAB SYSTEM ===================== */
async function switchTab(name){
  if(!isLoggedIn()){
    document.querySelectorAll(".tabPanel").forEach(p=>p.style.display="none");
    document.getElementById("tab-login").style.display="block";
    document.querySelectorAll(".tab").forEach(t=>t.classList.remove("active"));
    return;
  }

  document.querySelectorAll(".tab").forEach(t=>t.classList.remove("active"));
  document.querySelectorAll(".tabPanel").forEach(p=>p.style.display="none");

  document.querySelector(`.tab[data-tab="${name}"]`).classList.add("active");
  document.getElementById("tab-"+name).style.display="block";

  if(name === "enemydb"){
    await renderEnemyDB();
    await renderTopEnemySources();
  }

  if(name === "analysis") await renderThreatBoard();
  if(name === "notes") await renderTokenStats();

  if(name === "settings"){
    await updateUserUI();
    if(await isAdmin()) await renderAdminStats();
  }
}

/* ===================== EVENTS ===================== */
document.querySelectorAll(".tab").forEach(tab=>{
  tab.addEventListener("click", async ()=> await switchTab(tab.getAttribute("data-tab")));
});

/* ===== AUTH EVENTS ===== */
document.getElementById("btnRegister").addEventListener("click", async ()=>{
  const nick = normalizeNick(document.getElementById("regNick").value);
  const pass = document.getElementById("regPass").value.trim();
  const code = document.getElementById("regCode").value.trim();

  if(!nick || nick.length < 3){
    toast("B≈ÇƒÖd", "Nick jest za kr√≥tki.");
    return;
  }
  if(!pass || pass.length < 3){
    toast("B≈ÇƒÖd", "Has≈Ço jest za kr√≥tkie.");
    return;
  }
  if(code !== TRIBE_CODE){
    toast("B≈ÇƒÖd", "Niepoprawny kod plemienia.");
    return;
  }

  const users = await loadUsers();

  if(users[nick]){
    toast("B≈ÇƒÖd", "Taki nick ju≈º istnieje.");
    return;
  }

  users[nick] = {
    nick,
    pass,
    createdAt: nowISO(),
    is_admin: false
  };

  await saveUsers(users);

  toast("OK", "Konto utworzone. Mo≈ºesz siƒô zalogowaƒá.");
});

document.getElementById("btnLogin").addEventListener("click", async ()=>{
  const nick = normalizeNick(document.getElementById("loginNick").value);
  const pass = document.getElementById("loginPass").value.trim();

  const users = await loadUsers();
  if(!users[nick] || users[nick].pass !== pass){
    toast("B≈ÇƒÖd", "Niepoprawny login lub has≈Ço.");
    return;
  }

  saveSession({ nick, loggedAt: nowISO() });
  toast("OK", `Zalogowano jako ${nick}`);

  await updateUserUI();
  await switchTab("labels");
});

document.getElementById("btnLogout").addEventListener("click", async ()=>{
  clearSession();
  toast("Konto", "Wylogowano.");
  await updateUserUI();
  await switchTab("login");
});

/* ===== LABELS TAB ===== */
document.getElementById("btnParseLabels").addEventListener("click", async ()=>{
  const user = getCurrentUser();
  if(!user){
    toast("B≈ÇƒÖd", "Musisz byƒá zalogowany.");
    return;
  }

  const btn = document.getElementById("btnParseLabels");

  try{
    btn.disabled = true;
    showLabelsLoader("Parsowanie etykiet...", 10);

    const text = document.getElementById("labelsInput").value;
    const parsed = parseEnemyLabels(text);

    if(parsed.length === 0){
      hideLabelsLoader();
      btn.disabled = false;
      toast("Etykiety", "Nie wykryto atak√≥w.");
      return;
    }

    showLabelsLoader("Zapisywanie defender√≥w...", 30);

    // przypisanie owner + zapis defender√≥w jako moje wioski
    const myVillages = new Set(await loadMyVillages());

    for(const a of parsed){
      a.owner = user.nick;
      a.ownerAddedAt = nowISO();
      if(a.defender) myVillages.add(a.defender);
    }

    await saveMyVillages([...myVillages]);

    showLabelsLoader("Pobieranie globalnej bazy...", 55);

    // zapis globalny bez duplikat√≥w (lokalnie)
    const old = await loadGlobalLabels();
    const combined = old.concat(parsed);

    const uniqueMap = {};
    for(const a of combined){
      const key = `${a.owner}|${a.defender}|${a.source}|${a.arrival}|${a.raw}`;
      uniqueMap[key] = a;
    }

    showLabelsLoader("Wysy≈Çanie do Supabase...", 80);

    // Zmienione: zapisuje tylko unikalne z combined (jak wcze≈õniej),
    // ale saveGlobalLabels nie pobiera ju≈º ca≈Çej tabeli supabase.
    await saveGlobalLabels(Object.values(uniqueMap));
    await updateTribeLabelsCount();

    showLabelsLoader("Generowanie podsumowania...", 95);

    // podsumowanie tylko nowych
    const summary = document.getElementById("labelsSummary");
    const byDef = groupBy(parsed, a=>a.defender);

    let html = "";
    for(const def in byDef){
      html += `<div class="item">
        <div class="inline">
          <div>
            <div class="mono"><b>${escapeHtml(def)}</b></div>
            <div class="small">Nowych atak√≥w: <b class="mono">${byDef[def].length}</b></div>
          </div>
          <span class="tag blue">OK</span>
        </div>
      </div>`;
    }

    summary.innerHTML = html;

    showLabelsLoader("Gotowe!", 100);

    setTimeout(()=>{
      hideLabelsLoader();
    }, 600);

    toast("Etykiety", `Dodano atak√≥w: ${parsed.length}`);

  }catch(e){
    console.error(e);
    hideLabelsLoader();
    toast("B≈ÇƒÖd", "Nie uda≈Ço siƒô zapisaƒá etykiet.");
  }finally{
    btn.disabled = false;
  }
});

document.getElementById("btnClearLabels").addEventListener("click", ()=>{
  document.getElementById("labelsInput").value = "";
  document.getElementById("labelsSummary").innerHTML = `<div class="item small">Brak danych.</div>`;
});

document.getElementById("btnDeleteMyLabels").addEventListener("click", async ()=>{
  const user = getCurrentUser();
  if(!user) return;

  if(!confirm("UsunƒÖƒá wszystkie Twoje etykiety z globalnej bazy?")) return;

  const { error } = await supa
    .from("attack_labels")
    .delete()
    .eq("owner_nick", user.nick);

  if(error){
    toast("B≈ÇƒÖd", error.message);
    return;
  }

  toast("OK", "Usuniƒôto Twoje etykiety.");

  await updateTribeLabelsCount();
  await renderThreatBoard();
  await renderTopEnemySources();
});

/* ===== NOTES TAB ===== */
document.getElementById("btnParseTokens").addEventListener("click", async ()=>{
  const text = document.getElementById("notesInput").value;
  const tokens = extractTokens(text);

  if(tokens.length === 0){
    await renderTokenStats(0);
    toast("Tokeny", "Nie znaleziono token√≥w HN1/HN2.");
    return;
  }

  await renderTokenStats(tokens.length);
  toast("Tokeny", `Wykryto token√≥w: ${tokens.length}`);
});

document.getElementById("btnAddTokens").addEventListener("click", async ()=>{
  if(!(await isAdmin())){
    toast("Brak dostƒôpu", "Tylko admin mo≈ºe dodawaƒá tokeny.");
    return;
  }

  const text = document.getElementById("notesInput").value;
  const tokens = extractTokens(text);

  if(tokens.length === 0){
    toast("Brak token√≥w", "Nie wykryto HN1/HN2.");
    return;
  }

  const db = await loadDB();
  let added = 0;

  for(const token of tokens){
    try{
      const decoded = decodeHN(token);
      const coords = `${decoded.x}|${decoded.y}`;
      const troops = troopsArrayToObj(decoded.u);
      const type = classifyVillage(troops);

      db[coords] = {
        coords,
        troops,
        troopsAfter: troops,
        type,
        updatedAt: nowISO(),
        token
      };

      added++;
    }catch(e){}
  }

  await saveDB(db);
  toast("Baza", `Dodano/zaaktualizowano: ${added} wiosek.`);
  await renderTokenStats();
});

/* ===== ENEMY DB TAB ===== */
document.getElementById("btnEnemySearch").addEventListener("click", ()=>{
  const coords = document.getElementById("enemySearch").value.trim();
  if(!coords) return;
  renderEnemyProfile(coords);
});

/* ===== ANALYSIS TAB ===== */
document.getElementById("btnRunThreat").addEventListener("click", async ()=>{
  await renderThreatBoard();
  toast("Analiza", "Przeliczono zagro≈ºenia.");
});
document.getElementById("btnClearThreat").addEventListener("click", ()=>{
  document.getElementById("threatBoard").innerHTML = `<div class="item small">Wyczy≈õƒá dane w ustawieniach je≈õli chcesz usunƒÖƒá historiƒô.</div>`;
});

/* ===== SETTINGS ADMIN ===== */
document.getElementById("btnGrantAdmin").addEventListener("click", async ()=>{
  if(!(await isAdmin())) return;

  const nick = normalizeNick(document.getElementById("adminNickInput").value);
  if(!nick){
    toast("B≈ÇƒÖd", "Podaj nick.");
    return;
  }

  const users = await loadUsers();
  if(!users[nick]){
    toast("B≈ÇƒÖd", "Nie ma takiego u≈ºytkownika.");
    return;
  }

  const admins = await loadAdmins();
  if(admins.includes(nick)){
    toast("Info", "Ten gracz ju≈º jest adminem.");
    return;
  }

  admins.push(nick);
  await saveAdmins(admins);

  toast("Admin", `Nadano admina: ${nick}`);
  await updateUserUI();
});

document.getElementById("btnRevokeAdmin").addEventListener("click", async ()=>{
  if(!(await isAdmin())) return;

  const nick = normalizeNick(document.getElementById("adminNickInput").value);
  if(!nick){
    toast("B≈ÇƒÖd", "Podaj nick.");
    return;
  }

  if(nick === DEFAULT_ADMIN){
    toast("B≈ÇƒÖd", "Nie mo≈ºna usunƒÖƒá g≈Ç√≥wnego admina.");
    return;
  }

  const admins = (await loadAdmins()).filter(a => a !== nick);
  await saveAdmins(admins);

  toast("Admin", `Usuniƒôto admina: ${nick}`);
  await updateUserUI();
});

/* ===================== FIXED RESET LABELS ===================== */
document.getElementById("btnResetLabels").addEventListener("click", async ()=>{
  if(!(await isAdmin())) return;

  if(!confirm("UsunƒÖƒá wszystkie globalne etykiety atak√≥w?")) return;

  const { error } = await supa
    .from("attack_labels")
    .delete()
    .gt("created_at", "1970-01-01");

  if(error){
    toast("B≈ÇƒÖd", error.message);
    return;
  }

  toast("Reset", "Usuniƒôto globalne etykiety.");
  await updateTribeLabelsCount();

  document.getElementById("labelsSummary").innerHTML = `<div class="item small">Brak danych.</div>`;
  document.getElementById("threatBoard").innerHTML = `<div class="item small">Brak analizy. Wklej etykiety w zak≈Çadce "Etykiety Atak√≥w".</div>`;
  document.getElementById("enemyTopSources").innerHTML = `<div class="item small">Brak danych.</div>`;
});

/* ===================== FIXED RESET ALL ===================== */
document.getElementById("btnResetAll").addEventListener("click", async ()=>{
  if(!(await isAdmin())) return;

  if(!confirm("UsunƒÖƒá CA≈ÅƒÑ bazƒô (tokeny + etykiety + konta)?")) return;

  await supa.from("enemy_tokens").delete().gt("updated_at", "1970-01-01");
  await supa.from("attack_labels").delete().gt("created_at", "1970-01-01");

  toast("Reset", "Wyczyszczono wszystko.");
  location.reload();
});

/* ===== EXPORT / IMPORT ===== */
document.getElementById("btnExport").addEventListener("click", async ()=>{
  if(!(await isAdmin())) return;

  const payload = {
    version:"v4",
    exportedAt: nowISO(),
    db: await loadDB(),
    globalLabels: await loadGlobalLabels(),
    users: await loadUsers(),
    admins: await loadAdmins()
  };

  const blob = new Blob([JSON.stringify(payload,null,2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "tribal_intel_export.json";
  a.click();
  URL.revokeObjectURL(url);

  toast("Export", "Zapisano plik JSON.");
});

document.getElementById("btnImport").addEventListener("click", async ()=>{
  if(!(await isAdmin())) return;

  const inp = document.createElement("input");
  inp.type="file";
  inp.accept="application/json";
  inp.onchange = ()=>{
    const file = inp.files[0];
    if(!file) return;
    const reader = new FileReader();
    reader.onload = async ()=>{
      try{
        const obj = JSON.parse(reader.result);

        if(obj.db) await saveDB(obj.db);
        if(obj.globalLabels) await saveGlobalLabels(obj.globalLabels);
        if(obj.users) await saveUsers(obj.users);
        if(obj.admins) await saveAdmins(obj.admins);

        toast("Import", "Zaimportowano dane.");
        await updateTribeLabelsCount();
      }catch(e){
        toast("B≈ÇƒÖd", "Nie uda≈Ço siƒô zaimportowaƒá.");
      }
    };
    reader.readAsText(file);
  };
  inp.click();
});

/* ===================== INIT ===================== */
async function init(){
  await updateUserUI();

  if(!isLoggedIn()){
    document.querySelectorAll(".tabPanel").forEach(p=>p.style.display="none");
    document.getElementById("tab-login").style.display="block";
    return;
  }

  await switchTab("labels");
  await renderTokenStats();
  await renderEnemyDB();
}

init();
updateTribeLabelsCount();
</script>

</body>
</html>
